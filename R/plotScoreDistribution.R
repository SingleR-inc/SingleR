#' Plot score distributions of labels.
#'
#' @param results A \linkS4class{DataFrame} containing the output from \code{\link{SingleR}} or \code{\link{classifySingleR}}.
#' @param show String specifying whether to show the scores, the difference from the median or the difference from the next-best score.
#' @param labels.use String vector indicating one or more labels to show.
#' If \code{NULL}, all labels available in \code{results} are presented.
#' @param calls.use,pruned.use Integer scalar specifying which labels or pruning calls to use, defaulting to those from the top-level \code{results}.
#' However, this can also refer to any column index of \code{results$orig.results} to use labels from individual references in a combined prediction (see \code{?\link{combine-predictions}}.
#'
#' Alternatively, an integer vector of the same length as \code{scores.use},
#' specifying the labels to use in each plot generated by \code{scores.use}.
#' @param scores.use Integer scalar specifying which scores to use.
#' However, this can also refer to any column index of \code{results$orig.results} to use scores from individual references in a combined prediction (see \code{?\link{combine-predictions}}.
#'
#' Alternatively, \code{scores.use} can be an integer vector containing multiple such column indices (or zero).
#' In such cases, multiple plots will be created showing multiple sets of scores.
#'
#' Default setting, \code{scores.use=NULL}, will create plots for all targets that make sense:
#' when \code{show="scores"} plots are created for top-level results & individual references;
#' when \code{show="delta.med"} or \code{"delta.next"}, plots are created for individual references;
#'
#' @param dots.on.top Logical specifying whether cell dots should be plotted on top of the violin plots.
#' @param this.color String specifying the color for cells that were assigned to the label.
#' @param pruned.color String specifying the color for cells that were assigned to the label but pruned.
#' @param other.color String specifying the color for other cells not assigned to the label.
#' @param size Numeric scalar to set the size of the dots.
#' @param ncol Integer scalar to set the number of labels to display per row.
#' @param show.nmads Numeric scalar that shows the threshold that would be used for pruning with \code{\link{pruneScores}}.
#' Only used when \code{show="delta.med"}.
#' @param show.min.diff Numeric scalar that shows the threshold that would be used for pruning with \code{\link{pruneScores}}.
#' Only used when \code{show="delta.med"} or \code{"delta.next"}.
#' @param grid.vars named list of extra variables to pass to \code{\link[gridExtra]{grid.arrange}},
#' used when \code{scores.use} is of length greater than 1.
#' If \code{NULL}, the function will not arrange plots on a grid but simply create them one after another on the graphics device.
#'
#' @return
#' One or more \link[ggplot2]{ggplot} objects showing assignment scores in violin plots is generated on the current graphics device.
#' A list of such objects is returned if \code{scores.use} is of length greater than 1.
#'
#' @details
#' This function creates jitter and violin plots showing assignment scores or related values for all cells across one or more labels.
#' It is intended for visualizing and adjusting the \code{nmads}, \code{min.diff.med}, and \code{min.diff.next} cutoffs of the \code{\link{pruneScores}} function.
#'
#' The \code{show} argument determines what values to show on the y-axis.
#' Options are:
#' \itemize{
#' \item \code{"delta.med"}, the difference between the score of the assigned label and the median of all scores for each cell.
#' \item \code{"delta.next"}, the difference between best and second-best tuning scores of each cell.
#' \item \code{"scores"}, the raw assignment scores prior to fine-tuning.
#' }
#'
#' For a given label X, cells distributions in several categories are shown:
#' \itemize{
#' \item Was assigned to label X, and the label was not pruned away.
#' \item Was assigned to label X, and the label was pruned away.
#' \item Was assigned as any label, including label X.
#' }
#' Each category is grouped and colored separately based on \code{this.color} and related parameters.
#'
#' Values are stratified according to the assigned labels in \code{results$labels}.
#' If any fine-tuning was performed, the highest scoring label for an individual cell may not be its final label.
#' This may manifest as negative values when \code{show="delta.med"}.
#'
#' Also note that \code{\link{pruneScores}} trims based on the \code{min.diff.med} and \code{min.diff.next} cutoffs first,
#' before calculating the first-labels' delta medians.
#' Thus, the actual \code{nmads} cut-off used in \code{\link{pruneScores}} may vary from the one portrayed in the plot.
#'
#' @seealso
#' \code{\link{SingleR}}, to generate scores.
#'
#' \code{\link{pruneScores}}, to remove low-quality labels based on the scores, and to see more about the quailty cutoffs.
#'
#' @author Daniel Bunis and Aaron Lun
#' @examples
#' example(SingleR, echo=FALSE)
#'
#' # To show the distribution of scores grouped by label:
#' plotScoreDistribution(results = pred)
#' # We can display a particular label using the label
#' plotScoreDistribution(results = pred,
#'     labels.use = "B")
#'
#' # To show the distribution of deltas between cells' maximum and median scores,
#' #   grouped by label, change 'show' to "delta.med":
#' #   This is useful for checking/adjusting nmads and min.diff.med cutoffs
#' plotScoreDistribution(results = pred,
#'     show = "delta.med")
#'
#' # To show the distribution of deltas between cells' top 2 fine-tuning scores,
#' #   grouped by label, change `show` to "delta.next":
#' #   This is useful for checking/adjusting min.diff.next cutoffs
#' plotScoreDistribution(results = pred, show = "delta.next")
#'
#'
#' ### Visualizing and adjusting pruning cutoffs ###
#'
#' # The default nmads cutoff of 3 is displayed when 'show = "delta.med"', but
#' # this can be adjusted or turned off with 'show.nmads'
#' plotScoreDistribution(results = pred,
#'     show = "delta.med", show.nmads = 2)
#' plotScoreDistribution(results = pred,
#'     show = "delta.med", show.nmads = NULL)
#'
#' # A min.diff cutoff can be shown using 'show.min.diff' when
#' # 'show = "delta.med"' or 'show = "delta.next"'
#' plotScoreDistribution(results = pred,
#'     show = "delta.med", show.min.diff = 0.03)
#' plotScoreDistribution(results = pred,
#'     show = "delta.next", show.min.diff = 0.03)
#'
#'
#' ### Multi-Reference Compatibility ###
#'
#' # When SingleR is run with multiple references, default output will contain
#' # separate plots for each original reference, as well as for the the combined
#' # set when 'show' = "scores".
#' example(combineRecomputedResults, echo = FALSE)
#' plotScoreDistribution(results = combined)
#'
#' # 'scores.use' sets which original results to plot distributions for, and can
#' # be multiple or NULL (default)
#' plotScoreDistribution(results = combined, show = "scores",
#'     scores.use = 0)
#' plotScoreDistribution(results = combined, show = "scores",
#'     scores.use = 1:2)
#'
#' # To color and group cells by non-final label and pruned calls,
#' # use 'calls.use' and 'pruned.use'
#' plotScoreDistribution(results = combined, show = "scores",
#'     calls.use = 1, pruned.use = 1)
#'
#' # To have plots output in a grid rather than as separate pages, provide,
#' # a list of inputs for gridExtra::grid.arrange() to 'grids.vars'.
#' plotScoreDistribution(combined,
#'     grid.vars = list(ncol = 1))
#'
#' # An empty list will use grid.arrange defaluts
#' plotScoreDistribution(combined,
#'     grid.vars = list())
#'
#' @export
plotScoreDistribution <- function(
    results,
    show = c("scores", "delta.med", "delta.next"),
    labels.use = colnames(results$scores),
    scores.use = NULL,
    calls.use = 0,
    pruned.use = 0,
    size = 0.5,
    ncol = 5,
    dots.on.top = TRUE,
    this.color = "#F0E442",
    pruned.color = "#E69F00",
    other.color = "gray60",
    show.nmads = 3,
    show.min.diff = NULL,
    grid.vars = list())
{
    results <- .ensure_named(results)
    show <- match.arg(show)
    is.combined <- !is.null(results$orig.results)
    ref.names <- colnames(results$orig.results)

    if (is.null(scores.use)) {
        if (is.combined && show != "scores") {
            scores.use <- seq_along(results$orig.results) # combined 'delta.med'/'delta.next' ar enot worth showing.
        } else {
            scores.use <- c(0L, seq_along(results$orig.results)) # seq_along(NULL) is nothing.
        }
    }
    calls.use <- rep(calls.use, length.out=length(scores.use))
    pruned.use <- rep(pruned.use, length.out=length(scores.use))

    if (is.combined && show == "delta.next" && any(calls.use != scores.use)) {
        message("'calls.use', and 'scores.use' must be the same for 'show=\"delta.next\"'. 'calls.use' updated.")
        calls.use <- scores.use
    }

    use.grid <- !is.null(grid.vars) && length(scores.use) > 1L

    plots <- vector("list", length(scores.use))
    for (i in seq_along(plots)) {

        # Pulling out the scores to use in this iteration.
        chosen.scores <- scores.use[i]
        if (chosen.scores==0L) {
            score.results <- results
            if (is.combined && show != "scores") {
                stop("'show = ",show,"' cannot be used for combined results.")
            }
        } else {
            score.results <- results$orig.results[[chosen.scores]]
        }

        scores <- score.results$scores
        tuning.scores <- score.results$tuning.scores
        scores.title <- .values_title(is.combined, chosen.scores, ref.names, show)

        # Pulling out the labels to use in this iteration.
        chosen.calls <- calls.use[i]
        if (chosen.calls==0L) {
            call.results <- results
        } else {
            call.results <- results$orig.results[[chosen.calls]]
        }

        labels <- call.results$labels
        labels.title <- .values_title(is.combined, chosen.calls, ref.names, "Labels")

        # Pulling out the pruning calls to use in this iteration.
        chosen.pruned <- pruned.use[i]
        if (chosen.pruned==0L) {
            prune.results <- results
        } else {
            prune.results <- results$orig.results[[chosen.pruned]]
        }

        prune.calls <- prune.results$pruned.labels
        prune.title <- .values_title(
            is.combined, chosen.pruned, paste0("(",ref.names,")"), "pruned")

        # Calculate nmad.cutoff values for 'show.nmads'
        if (show == "delta.med" && !is.null(show.nmads)) {
            nmad.vals <- pruneScores(score.results, get.thresholds=TRUE, nmads = show.nmads)
        }

        # Actually creating the plot
        output <- .plot_score_distribution(
            show, scores, tuning.scores, labels, prune.calls, labels.use,
            labels.title, scores.title, prune.title,
            this.color, pruned.color, other.color, size, ncol, dots.on.top,
            show.nmads, show.min.diff, nmad.vals)

        plots[[i]] <- output
    }

    if (length(plots)==1L) {
        # Doing this to be consistent with raw ggplot output.
        plots[[1]]
    } else {
        if (use.grid) {
            do.call(gridExtra::grid.arrange, c(plots, grid.vars))
        } else {
            plots
        }
    }
}

.plot_score_distribution <- function(
    show, scores, tuning.scores, labels, prune.calls, labels.use,
    labels.title, scores.title, prune.title,
    this.color, pruned.color, other.color, size, ncol, dots.on.top,
    show.nmads, show.min.diff, nmad.vals) {

    # Make data frame
    if (show!="delta.next") {
        df <- .scores_df_gather(
            show, scores, labels, prune.calls, prune.title)
    } else {
        df <- .next_df_gather(
            tuning.scores, labels, prune.calls, prune.title)
    }

    # Trim dataframe by labels
    if (any(labels.use %in% df$label)) {
        labels.use <- labels.use[labels.use %in% df$label]
        df <- df[df$label %in% labels.use,]
    } else {
        message("No 'labels.use' in ", scores.title, ". Ignoring input.")
    }

    # Set plot values and theming
    p <- ggplot2::ggplot(data = df,
            ggplot2::aes_string(x = "cell.calls", y = "values", fill = "cell.calls")) +
        ggplot2::theme_classic() +
        ggplot2::scale_fill_manual(
            name = labels.title,
            breaks = c("assigned", prune.title, "other"),
            values = c(this.color, pruned.color, other.color)) +
        ggplot2::facet_wrap(facets = ~label, ncol = ncol) +
        ggplot2::ylab(scores.title)

    if (length(levels(as.factor(df$label))) == 1) {
        p <- p + ggplot2::scale_x_discrete(name = NULL, labels = NULL)
    } else {
        p <- p + ggplot2::scale_x_discrete(name = "Labels", labels = NULL)
    }

    # Adding the data:
    if (!dots.on.top) {
        p <- p + ggplot2::geom_jitter(
            height = 0, width = 0.3, color = "black", shape = 16,size = size,
            na.rm = TRUE)
    }

    p <- p + ggplot2::geom_violin(na.rm=TRUE)

    if (dots.on.top) {
        p <- p + ggplot2::geom_jitter(
            height = 0, width = 0.3, color = "black", shape = 16,size = size,
            na.rm = TRUE)
    }

    # Add cutoff lines
    if (grepl("delta",show) && !is.null(show.nmads) || !(is.null(show.min.diff))) {
            p <- .add_cutoff_lines(
                p, show, show.nmads, show.min.diff, nmad.vals, labels.use)
        }

    p
}

#' @importFrom DelayedMatrixStats rowMedians
.scores_df_gather <- function(
    show, values, labels, prune.calls, prune.title) {

    if (show=="delta.med") {
        values <- values - DelayedMatrixStats::rowMedians(DelayedArray(values), na.rm = TRUE)
    }

    # Create a dataframe with separate rows for each score in values.
    df <- data.frame(
        label = rep(colnames(values), nrow(values)),
        values = as.numeric(t(values)),
        stringsAsFactors = FALSE)

    # Add whether this label is the final label given to each cell.
    df$cell.calls <- rep("other", nrow(df)) # rep() protects when nrow(df)=0.
    is.called <- df$label == rep(labels, each=ncol(values))
    df$cell.calls[is.called] <- "assigned"
    # Replace cell.call if cell was pruned.
    if (!is.null(prune.calls)) {
        is.pruned <- rep(is.na(prune.calls), each=ncol(values))
        df$cell.calls[is.pruned & is.called] <- prune.title
    }

    df
}

.next_df_gather <- function(
    tuning.scores, labels, prune.calls, prune.title) {

    if (is.null(tuning.scores)) {
        stop("Target 'results' lacks fine-tuning diagnostics for 'show=\"delta.next\"'")
    }

    df <- data.frame(
        values = tuning.scores$first - tuning.scores$second,
        label = labels,
        cell.calls = rep("assigned", nrow(tuning.scores)), # don't unrep, protects when nrow(tuning.scores)=0.
        stringsAsFactors = FALSE)

    if (!is.null(prune.calls)) {
        df$cell.calls[is.na(prune.calls)] <- prune.title
    }

    df
}

.add_cutoff_lines <- function(
    p, show, show.nmads, show.min.diff, nmad.vals, labels.use) {

    if (show == "delta.med" && !is.null(show.nmads)) {
        # Add cutoff line for nmads cutoff
            # Uses geom_error (error bars, but with ymin = ymax)
        p <- .add_nmads_lines(p, nmad.vals, labels.use)
    }

    if (grepl("delta",show) && !(is.null(show.min.diff))) {
        # Add cutoff line for min.diff cutoff
        df_min.diff <- data.frame(color = "2.min.diff", show.min.diff = show.min.diff)
        p <- p +
            ggplot2::geom_hline(
                data = df_min.diff, na.rm = TRUE, size = 1.1,
                ggplot2::aes_string(yintercept = "show.min.diff", color = "color"))
    }

    # Set the colors and a=labels for combined legend.
    p <- p + ggplot2::scale_color_manual(
        name = "Lines",
        values = c(
            '1.nmad' = "#0072B2",
            '2.min.diff' = "red"),
        labels = c(
            '1.nmad' = "nmad cutoff",
            '2.min.diff' = "min.diff cutoff")
        ) +
        ggplot2::guides(
            color = ggplot2::guide_legend(override.aes = list(size=2)))

    p
}

#' @importFrom stats median mad
.add_nmads_lines <- function(p, nmad.vals, labels.use) {

    df <- data.frame(
        label=names(nmad.vals),
        nmads.cutoff=nmad.vals,
        values=0, # to keep the inherited aes_string() happy.
        cell.calls=rep("assigned", length(nmad.vals)),
        mad=rep("1.nmad", length(nmad.vals))) # Add dummy var for setting color later.

    df <- df[df$label %in% labels.use, , drop=FALSE]

    p + ggplot2::geom_errorbar(data = df, na.rm=TRUE,
        ggplot2::aes_string(x = "cell.calls", ymin= "nmads.cutoff", ymax= "nmads.cutoff", color = "mad"),
        width = 1, size = 1.1, show.legend = c(color = TRUE, fill = FALSE))
}
